```
가바지 컬렉션
   - 프로그램을 개발하다 보면 유효하지 않은 메모리인 가비지가 발생하게 된다. c언어의 경우 직접 메모리를 해제해 줘야 하지만, 자바나 코틀린을 이용해 개발하다 보면 메모리를 직접 해제해주는 일이 없다.
     이유는 가비지 컬렉터가 불필요한 메모리를 알아서 정리해 주기 때문이다. 대신 자바에서 명시적으로 불필요한 데이터를 표현하기 위해서 일반적으로 null을 선언해준다.
        Minor gc와 Major gc
            - jvm의 heap영역은 처음 설계될 때 다음의 2가지 전제로 설계되었다.
                (1) 대부분의 객체는 금방 접근 불가능한 상태가 된다.
                (2) 오래된 객체에서 새로운 객체로의  참조는 아주 적게 존재한다. 
                즉 객체는 대부분 일회성이며, 메모리에 오랫동안 남아있는 경우는 드믈다는 것이다. 그렇기 때문에 객체의 생존 기간에 따라 물리적인 힙 영역을 나누게 되었고 young, old 총 2가지 영역으로 설계되었다.
                young 영역
                    새롭게 생성된 객체가 할당된 영역
                    대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 많은 객체가 young 영역에 생성되었다가 사라진다
                    young 영역에 대한 가비지 컬렉션(Garbage Collection)을 Minor GC라고 부른다.
                old 영역
                    young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
                    young 영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생한다.
                    old 영역에 대한 가비지 컬렉션(Garbage Collection)을 Major GC라고 부른다.
                (3) old영역이 young 영역보다 크게 할당되는 이유는 young 영역의 수명이 짧은 객체들은 큰 공간을 필요로 하지 않으며 큰 객체들은 young 영역이 아니라 old 영역에 할당되기 때문이다.
                (4) 예외적인 상황으로 old 영역에 있는 객체가 young 영역의 객체를 참조하는 경우도 존재할 것이다. 이러한 경우를 대비하여 old 영역에는 512byte 덩어리로 되어 있는 카드 테이블이 존재한다.
                (5) 카드 테이블에는 old 영역에 있는 객체가 young 영역의 객체를 참조할 때 마다 그데 대한 정보가 표시된다. 카드 테이블이 도입된 이유는 young 영역에서 가비지 컬렉터가 실행될 때 모든 old 영역의 객체를 검사하여
                    참조되지 않는 young 영역의 객체를 식별하는 것은 비효율적이기 때문이다. 따라서 카드 테이블만 조회하여 가비지 컬렉터의 대상인지 식별하게 하고 있다.
   - 가비지 컬렉션의 young 영역과 old 영역은 서로 다른 메모리 구조로 되어 있기 때문에, 세부적인 동작 방식은 다르다. 2가지 공통적인 단계를 따른다
    (1) stop the world
        가비지 컬렉션을 실행하기 위해 jvm이 애플리케이션의 실행을 멈추는 작업이다. 가비컬렉션을 제외한 모든 쓰레드들의 작을 중단하고 완료되면 재개한다.
        당연히 모든 쓰레드들의 작업이 중단되면 애플리케이션이 멈추기 때문에, gc의 성능 개션을 위해 튜닝을 한다고 하면 보통 stop the world의 시간을 줄이는 작업을 하는것이다.
    (2) mark and sweep
        mark: 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업
        sweep: mark 단계에서 사용되지 않음으로 식별되지 않은 메모리를 해제하는 작업
        Stop The World를 통해 모든 작업을 중단시키면, GC는 스택의 모든 변수 또는 Reachable 객체를 스캔하면서 각각이 어떤 객체를 참고하고 있는지를 탐색하게 된다. 그리고 사용되고 있는 메모리를 식별하는데, 이러한 과정을 Mark라고 한다. 이후에 Mark가 되지 않은 객체들을 메모리에서 제거하는데, 이러한 과정을 Sweep라고 한다.
    - Minor gc의 동작 방식
        young 영역은 1개의 eden 영역과 2개의 suvivor 영역으로 나누어진다.
           (1) Eden 영역: 새로 생성된 객체가 할당(Allocation)되는 영역
           (2) Survivor 영역: 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역
        새로 생성된 객체가 eden 영역에 할당된다 -> 객체가 계속 생성되어 eden 영역이 꽉차게 되고 가비지 컬렉션이 실행된다.(eden 영역에서 사용되지 않은 메모리는 해제되고 살아남은 객체는 1개의 suvivor 영역으로 이동된다)
        위의 과정을 반복하다가 suvivor 영역이 가득 차게 되면 suvivor 영역의 살아남은 객체를 다른 suvivor 영역으로 이동시킨다.(한개의 suvivor는 반드시 비어야 한다)
        이러한 과정을 반복하여 살아남은 객체는 old 영역으로 이동된다.
        (객체의 생존 횟수를 카운트하기 위해 Minor GC에서 객체가 살아남은 횟수를 의미하는 age를 Object Header에 기록한다. 그리고 Minor GC 때 Object Header에 기록된 age를 보고 Promotion 여부를 결정한다.
         또한 Survivor 영역 중 1개는 반드시 사용이 되어야 한다. 만약 두 Survivor 영역에 모두 데이터가 존재하거나, 모두 사용량이 0이라면 현재 시스템이 정상적인 상황이 아님을 파악할 수 있다.)  
    - Major gc의 동작 방식
        Young 영역에서 오래 살아남은 객체는 Old 영역으로 Promotion됨을 확인할 수 있었다. 그리고 Major GC는 객체들이 계속 Promotion되어 Old 영역의 메모리가 부족해지면 발생하게 된다. Young 영역은 일반적으로 Old 영역보다 크키가 작기 때문에 GC가 보통 0.5초에서 1초 사이에 끝난다. 그렇기 때문에 Minor GC는 애플리케이션에 크게 영향을 주지 않는다.
        하지만 Old 영역은 Young 영역보다 크며 Young 영역을 참조할 수도 있다. 그렇기 때문에 Major GC는 일반적으로 Minor GC보다 시간이 오래걸리며, 10배 이상의 시간을 사용한다. 참고로 Young 영역과 Old 영역을 동시에 처리하는 GC는 Full GC라고 한다.

    tip: 가비지 컬렉션의 성능을 높이는 코딩 방법
    - colloection 의 크기를 예측하여 설정하라
    - stream을 사용하라
    - String의 사용을 최적화하라(중복된 string을 생성되는 경우, jvm 옵션을 활용하라 java -XX:+UseStringDeduplication -jar Application.java)
    - 불변객체를 활용하라
    - 불필요한 collection을 생성을 피해라


```