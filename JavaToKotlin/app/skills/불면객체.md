```
항상 좋은 코드를 얘기할 때면 불변 객체를 빼놓을 수 없다.

불변객체란 객체 생성 이후 내부의 상태가 변하지 않는 객체이다. read-only 메소드만을 제공하며, 객체 내부 상태를 제공하는 메소드가 없거나 방어적 복사를 통해 제공한다.
대표적으로 String이 있다.

java의 String은 불변 클래스이기 때문에 위와 같이 String 내부의 char형 배열을 얻어 수정하여도 반영이 되지 않는다. 자바에서는 배열이나 객체 등의 참조를 전달한다.
그렇기 때문에 참조를 통해 값을 수정하면 내부의 상태가 변하기 때문에 내부를 복사하여 전달하고 있는데, 이를 방어적 복사라고 한다.

불변객체 및 final을 사용해야 하는 이유

1. thread-safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
    - 멀티쓰레드 환경에서 동기화 문제가 발생하는 경우는 공유자원을 동시에 사용하기 떄문, 하지만 공유 자원이 불변이라면 동기화를 고려하지 않아도 된다. 왜냐하면 항상 동일한 값을 보장하기 때문이다.
    
2. 실패 원자적인 메소드를 만들 수 있다.(호출 된 메소드가 실패하더라도 해당 객체는 호출 전 상태를 유지한다)
    - 가변 객체를 통해 작업을 하는 도중 예외가 발생하면 해당 객체가 불안정한 상태에 빠질 수 있고, 불안정한 상태를 갖는 객체는 또 다른 에러를 유발할 수 있다. 하지만 불변 객체라면 어떠한 예외가 발생하여도 메소드 호출 전의 상태를 유지할 수 있을 것이다. 그리고 예외가 발생하여도 오류가 발생하지 않은 것 처럼 다음 로직을 처리할 수 있다.
    
3. Cache나 Map 또는 Set 등의 요소로 활용하기에 더욱 적합하다.
    - 캐시나 Map등의 원소인 가변 객체가 변경되었다면, 이를 생신하는 등의 부가 작업이 필요할 것이다. 하지만 불변 객체라면 저장 후 다른 작업들을 고려하지 않아도 된다.
    
4. 사이드 이펙트 오류가능성을 최소화 할 수 있다.
    - 만약 객체의 수정자를 통해 여러 객체들에서 값을 변경한다면 객체의 상태를 예측하기 어려워질 것이다. 불변객체는 기본적으로 값의 수정이 불가능하기 때문에 변경 가능성이 적으며, 객체의 생성과 사용이 상당히 제한된다.
      그렇기 때문에 메소드들은 자연스럽게 순수 함수들로 구성될 것이고, 다른 메소드가 호출되어도 객체의 상태가 유지되기 때문에 안전하게 객체를 다시 사용할 수 있다.
    
5. 다른 사람이 작성한 함수를 예측가능하며 안전하게 사용할 수 있다.
    - 일반적으로 개발은 다른 사람들과 협업하게 된다. 불변성은 협업 과정에서도 도움을 주는데, 불변성이 보장된 함수라면 다른 사람이 개발한 함수를 위험없이 사용할 수 있다.
    
6. 가비지 컬렉션의 성능을 높일 수 있다.
    - 불변의 객체를 활용하면 가비지 컬렉터가 스캔해야 되는 객체의 수가 줄어서 스캔해야 하는 메모리 영역과 빈도수 역시 줄어들 것이고, GC가 수행되어도 지연 시간을 줄일 수 있을 것이다. 그렇기 때문에 필드값을 수정할 수 있는 MutableHolder보다는 필드값을 수정할 수 없는 ImmutableHolder를 사용하는 것이 좋다.
```