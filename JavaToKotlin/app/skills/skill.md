```
1. JPA
    - 객체와 db테이블을 mapping시켜 rdb테이블을 객체지향적으로 사용하게 해준다.
    사용 이유
        - 엔티티에 맞는 테이블 생성 및 db 생성 편리
        - 객체 지향 중심의 개발
        - 테스트 작성 용이
        - 기본적인 crud 자동화
        - 복잡한 쿼리는 Query DSL을 사용해 처리

2. Static
    - static 키워드를 사용한다는 것은 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 것을 의미한다.
    - 우리가 만든 class는 static 영역에 생성되고 new 연산을 통해 생성된 객체는 heap영역에 생성된다. 객체의 생성시 할당된 heap 영역의 메모리는
      가비지 컬렉터를 통해 수시로 관리를 받는다. 하지만 static 영역에 할당된 메모리는 모든 객체가 공유하는 메모리라는 장점을 지니지만, 가비지 컬렉터 관리 영역
      밖에 존재하므로, static을 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재 하므로 주의를 해야 한다. 
    
    사용
        - 일반적으로 상수들의 값을 갖는 경우가 많으므로 public final을 붙여 사용한다. 
   
3. Otional
    - null이 올 수 있는 값을 감싸는 Wrapper 클래스이다. 참조하더라도 NPE가 발생하지 않도록 도와준다. Otional 클래스는 내부에서 static 변수로 empty 객체를 미리 생성해서 가지고 있다.
      이러한 이유로 빈 객체를 여러 번 생성해줘야 하는 겨웅에도 1개의 empty 객체를 공유함으로써 메모리를 절약하고 있다.
    
    사용
        - Optional.of() - 값이 Null이 아닌 경우
        - Optional.ofNullbale() - 값이 Null일수도, 아닐수도 있는 경우(이후에 orElse 또는 orElseGet 메소드를 이용해서 값이 없는 경우라도 안전하게 값을 가져올 수 있다.)

4. Enum
    - 일반적으로 상수를 정의할 때 public static final으로 상수를 정의한다. 하지만 이런식의 상수 정의는 다양한 문제를 발생시켰다. 따라서 열거형 클래스 enum을 도입하게 됨
        발생한 문제
            - 상수 값을 변경할 때
            - 컴파일 타임에 값을 할당받는데, 이러한 경우 사용자의 입력에 따라 다른 값을 이용할 수 없다.
            - 하드코딩되어있어 의존성이 높고 수정이 어렵다
            - 불필요한 메모리 사용 초래        
    
    사용이유
        - 코드가 단순해지며 가독성이 좋다.
        - 인스턴스 생성과 상속을 방지하여 컴파일 시에 상수값의 타입 안정성이 보장된다.
        - enum 키워드를  통해 구현의 의도가 열거임을 분명히 알 수 있다. 
        - enum과 functinal interface를 이용하여 확장성이라는 이점을 가질 수 있다. 구현된 기능중 하나인 좋아요(like) 기능에서 클라이언트에 들어오는 json 값을 
          enum에 열거하여, 그 값에 맞는 type을 찾아(게시물,댓글,공지 등...) 좋아요를 증가시킨다.

5. Lombok
    - 어노테이션 기반으로 코드를 자동완성 해주는 라이브러리이다. 롬복을 사용하여 코드의 가독성을 증가싴킬 수 있다.(VO 클래스에 수많은 get, set을 줄일 수 있다.)
    
    사용이유
        - 어노테이션 기반의 코드 자동 생성을 통한 생산성 향상
        - 반복되는 코드 다이어트를 통한 가독성 및 유지보수 향상
        - Getter, Setter 외에 빌더 패턴이나 로그 생성 등 다양한 방면으로 활용 가능
        - @Setter 어노테이션은 최대한 사용을 지양했다. 
    
    사용
        - @AllArgsConstructor: 모든 변수를 사용하는 생성자를 자동완성 시켜주는 어노테이션이다.
        - @NoArgsConstructor: 어떠한 변수도 사용하지 않는 기본 생성자를 자동완성 시켜주는 어노테이션이다.
        - @RequiredArgsConstructor: 특정 변수만을 활용하는 생성자를 자동완성 시켜주는 어노테이션이다. 생성자의 인자로 추가할 변수에 @NonNull 어노테이션을 붙여서 해당 변수를 생성자의 인자로 추가할 수 있다. 아니면 해당 변수를 final로 선언해도 의존성을 주입받을 수 있다.
        - @ToString: 클래스의 변수들을 기반으로 ToString 메소드를 자동으로 완성시켜 준다. 출력을 원하지 않는 변수에 @ToString.Exclude 어노테이션을 붙여주면 출력을 제외할 수 있다. 또한 상위 클래스에 대해도 toString을 적용시키고자 한다면 상위 클래스에 @ToString(callSuper = true) 를 적용시키면 된다.
        - @Data: @ToString, @EqualsAndHashCode, @Getter, @Setter, @RequiredArgsConstructor를 자동완성 시켜준다. 실무에서는 너무 무겁고 객체의 안정성을 지키기 때문에 @Data의 활용을 지양한다.
        - @Builder: 해당 클래스의 객체의 생성에 Builder패턴을 적용시켜준다.
        - @Delegate: 한 객체의 메소드를 다른 객체로 위임시켜 준다.

6. equals와 hashCode
    - equals와 hashCode는 모든 java 객체의 부모 객체인 object 클래스에 정의되어 있다. 따라서, java의 모든 객체는 equals와 hashCode를 상속받고 있다.
    - 기본적으로 두개의 객체가 동일한지 검사하기 위해 사용된다. equals가 구현된 방법은 2개의 객체가 참조하는 메모리가 동일한지 확인하는 것이며, 이는 동일성(identity) 를 비교하는 것이다,
      하지만 프로그래밍을 하다보면 동일한 객체가 메모리 상에 여러 개 띄워져 있는 경우가 있다. 해당 객체는 서로 다른 메모리에 띄워져있으므로 동일한(Identity) 객체가 아니다. 하지만 프로그래밍 상으로는 같은 값을 지니므로 같은 객체로 인식되어야 하는데, 이러한 동등성(Equality)를 위해 우리는 값으로 객체를 비교하도록 equals 메소드를 오버라이딩해주는 것이다.
      예를 들어 아래와 같이 동일한 값을 갖는 문자열을 2개 생성하면 각각은 서로 다른 메모리에 할당되므로 동일하지 않다. 대신 같은 값을 지니므로 동등하다. 하지만 동일성을 비교하는 equals 메소드를 호출해보면 true가 나오는데, 그 이유는 String 클래스에서 equals 메소드를 오버라이드하여 객체가 같은 값을 갖는지 동등성(Equality)을 비교하도록 처리했기 때문이다.
    - hashCode 메소드는 실행중에 객체의 유일한 integer값을 반환한다. object 클래스에서는 heap에 저장된 객체의 메모리 주소를 반환하도록 되어 있다.
    
    사용
        - equals를 재정의 하려거든 반드시 hashCode도 재정의 해서 사용하라

7.  Stream API
    - 자바에서 함수형 프로그램을 할 수 있게 해주는 api이다
    - 스트림에 대한 연산은 크게 생성하기, 가공하기, 결과 만들기 3가지 단계로 나누어 진다.
        - 생성하기: 스트림 객체를 생성한다.
        - 가공하기: 원본 데이터를 별도의 데이터로 가공하기 위한 중간 연산, 연산결과를 스트림으로 다시 반환하기 때문에 연속해서 중간 연산을 이어나갈 수 있다.
        - 결과만들기: 가공된 데이터로부터 원하는 결과를 만들기 위한 최종 연산, 스트림의 요소들을 소모하면서 연산이 수행되기 때문에 1번만 처리가능하디.
    
    사용이유
        - 원본의 데이터를 조회하여 별도의 요소들로 Stream을 생성한다. 그렇기 때문에 원본의 데이터를 변경하지 않는다.
        - Stram은 일회용이기 때문에 한번 사용이 끝나면 재사용이 불가능하다.
        - 반복문을 내부적으로 실행하기 때문에 보다 간결한 코드 작성이 가능하다.
        - 게시물 상세보기 기능에서 해당 게시물에 대한 댓글을 가공할 때 스트림을 사용했다 (현재는 주석처리 되어있음)

8. 람다식과 함수형 인터페이스
    - 스트림 연산들은 매개변수로 함수형 인터페이스를 받도록 되어 있다. 그리고 람다식은 반환값으로 함수형 인터페이스를 반환하고 있다. 그렇기 때문에 함수형 인터페이스와 람다식에 대한 이해가 필요하다
    - 람다식이란 함수를 하나의 식으로 표현한 것이다. 함수를 람다식으로 표현하면 메소드의 이름이 필요없기 때문에, 람다식은 익명함수의 한 종류라고 볼 수 있다.
    - 람다식으로 선언된 함수는 1급 객체이기 때문에 스트림의 매개변수로 전달이 가능하다.
        장점
            - 람다식 내에서 사용되는 지역변수는 final이 붙지 않아도 상수로 간주된다.
            - 람다식으로 선언된 변수명은 중복될 수 없다.
            - 코드를 간결하게 할 수 있다.
            - 의도가 명확히 들어나 가독성이 높아진다.
            - 병렬프로그래밍이 용이하다.
            - 함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아진다.
        단점
            - 람다를 사용하면서 만든 무명함수는 재사용이 불가능하다
            - 디버깅이 어렵다
            - 남발하면 함수가 중복 생성되어 코드가 지저분해진다
            - 재귀로 만들경우에 부적절하다
    - 함수형 인터페이스란 함수를 1급 객체처럼 다룰 수 있게 해주는 어노테이션으로, 인터페이스에 선언하여 단 하나의 추상 메소드만을 갖도록 제한하는 역할을 한다.
    - 함수형 인터페이스를 사용하는 이유는 자바의 람다식이 함수형 인터페이스를 반환하기 때문

9. 빌더패턴
    사용이유
        - 필요한 데이터만 설정할 수 있다.
        - 유연성 및 가독성 확보
```